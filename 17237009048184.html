<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	数据结构第二章——单链表 - 小吴日志
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="小吴日志" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://lskywhw.oss-cn-hangzhou.aliyuncs.com/2024/05/10/663df3f363cf2.png" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">小吴日志</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">首页</a></li>
						
						  <li id=""><a target="_self" href="archives.html">文章</a></li>
						
						  <li id=""><a target="_self" href="数据结构.html">数据结构</a></li>
						
						  <li id=""><a target="_self" href="Java.html">Java知识</a></li>
						
						  <li id=""><a target="_self" href="网络.html">网络知识</a></li>
						
						  <li id=""><a target="_self" href="感悟与思考.html">读书笔记</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">










<a target="_blank" class="github" target="_blank" href="https://github.com/2949-java" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:3351738701@qq.com" title="Email">Email</a>

								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">数据结构第二章——单链表</h1>
		<div class="entry-content" itemprop="articleBody">
			<h3><a id="%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>线性表的单链表存储结构</h3>
<pre><code class="language-c">#include &lt;string&gt;
#define ERROR 0  // 宏定义，错误返回值
#define TRUE 1   // 宏定义，正确返回值
// 链表节点结构体
typedef struct LNode{
    int data;        // 数据域
    LNode *next;     // 指向下一个节点的指针
}LNode,*LinkList;
</code></pre>
<h3><a id="%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%95%E9%93%BE%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>初始化单链表</h3>
<pre><code class="language-c">// 初始化链表
void InitList(LinkList &amp;L){
    L = (LinkList)malloc(sizeof(LNode));  // 分配内存
    if(!L)
        exit(-1);    // 内存分配失败
    L-&gt;next = NULL;   // 将链表的头结点的next指针置为NULL
}
</code></pre>
<h3><a id="%E5%A4%B4%E6%8F%92%E6%B3%95%E5%88%9B%E5%BB%BA%E5%8D%95%E9%93%BE%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>头插法创建单链表</h3>
<pre><code class="language-c">//前插法
void CreatListH(LinkList &amp;L,int n){
    int i;
    LinkList p;
    L = (LinkList)malloc(sizeof(LNode)); // 创建头结点
    L-&gt;next = NULL; // 将头结点的next指针置空
    printf(&quot;请输入%d个数据\n&quot;,n);
    for(i=n;i&gt;0;--i){ // 循环读入数据并插入链表
        p = (LinkList)malloc(sizeof(LNode)); // 创建新结点
        scanf(&quot;%d&quot;,&amp;p-&gt;data); // 读入数据
        p-&gt;next = L-&gt;next; // 将新结点的next指针指向头结点的next指针指向的第一个结点
        L-&gt;next = p; // 将头结点的next指针指向新结点
    }
}
</code></pre>
<h3><a id="%E5%B0%BE%E6%8F%92%E6%B3%95%E5%88%9B%E5%BB%BA%E5%8D%95%E9%93%BE%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>尾插法创建单链表</h3>
<pre><code class="language-c">void CreateLinkR(LinkList &amp;L,int n){
    int i;
    LinkList p ,q;
    L = (LinkList)malloc(sizeof(LNode));  // 为头结点分配内存空间
    L-&gt;next = NULL;  // 头结点指向NULL
    q = L;  // q指向头结点，q将作为尾指针用来指向链表的最后一个节点
    printf(&quot;请输入%d个数据\n&quot;,n);
    for(i=1;i&lt;=n;i++){
        p = (LinkList)malloc(sizeof(LNode));  // 为新节点分配内存空间
        scanf(&quot;%d&quot;,&amp;p-&gt;data);  // 输入节点数据
        q-&gt;next = p;  // 将q的后继节点指向新节点p
        q = q-&gt;next;  // q指向新节点p，更新q为新的尾指针
    }
    p-&gt;next = NULL;  // 新节点p指向NULL，表示链表已结束
}
</code></pre>
<h3><a id="%E9%94%80%E6%AF%81%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>销毁线性表（单链表）</h3>
<pre><code class="language-c">// 销毁链表
void DestroyList(LinkList &amp;L){
    LinkList q;
    while(L){   // 循环直到L为NULL
        q = L-&gt;next;   // q指向首元结点
        free(L);   // 释放头结点
        L = q;   // 将L指向原首元结点，现头结点
    }
}
</code></pre>
<h3><a id="%E6%B8%85%E7%A9%BA%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>清空线性表（单链表）</h3>
<pre><code class="language-c">// 清空链表，不改变L
void ClearList(LinkList L){
    LinkList p = L-&gt;next;   // p指向第一个节点
    L-&gt;next = NULL;   // 将链表的头结点的next指针域置为NULL
    DestroyList(p);   // 销毁p所指的单恋表
}
</code></pre>
<h3><a id="%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>判断链表是否为空</h3>
<pre><code class="language-c">// 判断链表是否为空
bool ListEmpty(LinkList L){
    if(L-&gt;next)//非空
        return ERROR;   // 存在节点，链表非空
    else
        return TRUE;   // 不存在节点，链表为空
}
</code></pre>
<h3><a id="%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>判断链表长度</h3>
<pre><code class="language-c">// 获取链表长度
int ListLength(LinkList L){
    int i = 0;//计数器初值为0
    LinkList p = L-&gt;next;   // p指向第一个节点
    while(p){//未到表尾
        i++;//计数器+1
        p = p-&gt;next;   //p指向下一个节点
    }
    return i;
}
</code></pre>
<h3><a id="%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取指定位置的元素值</h3>
<pre><code class="language-c">// 获取链表第i个元素值
int GetElem(LinkList L,int i,int &amp;e){
    int j = 1;//计数器初值为1
    LinkList p = L-&gt;next;   // p指向第一个节点
    while(p &amp;&amp; j&lt;i){   // 循环直到p为NULL或者p指向第i个结点
        j++;  //计数器+1
        p = p-&gt;next;   //p指向下一个节点
    }
    if(!p || j&gt;i)  //第i个节点不存在
        return ERROR;   // i小于1或大于链表长度，返回错误
    else
        e = p-&gt;data;   // 将p所指向的节点的值赋给e
    return TRUE;
}
</code></pre>
<h3><a id="%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定位元素</h3>
<pre><code class="language-c">// 定位元素
int LocateElem(LinkList L, int e, bool (*compare)(int, int)) {
    int i = 0;                // 计数器
    LinkList p = L-&gt;next;      // 头结点指向第一个节点
    while(p){
        i++;                  // 计数器自增
        if(compare(p-&gt;data,e))  // 如果找到了目标元素
            return i;         // 返回目标元素所在位置
        p = p-&gt;next;          // 遍历下一个节点
    }
    return 0;                 // 如果没有找到目标元素，返回0
}
</code></pre>
<h3><a id="%E8%8E%B7%E5%8F%96%E5%8D%95%E9%93%BE%E8%A1%A8%E5%89%8D%E9%A9%B1%E5%85%83%E7%B4%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取单链表前驱元素</h3>
<pre><code class="language-c">// 获取指定元素的前驱元素
bool PriorElem(LinkList L,int cru_e,int &amp;pre_e){
    LinkList q,p = L-&gt;next;    // p指向头结点的下一个节点，q指向p的下一个节点
    while(p &amp;&amp; p-&gt;next){       // 当p和p的下一个节点不为空时
        q = p-&gt;next;           // q指向p的下一个节点
        if(q-&gt;data == cru_e){  // 如果q的值等于要查找的元素
            pre_e = p-&gt;data;   // 则p的值为目标元素的前驱元素
            return TRUE;       // 返回true
        }
        p = q;                 // p指向q，继续遍历
    }
    return ERROR;              // 没有找到目标元素，返回ERROR
}
</code></pre>
<h3><a id="%E8%8E%B7%E5%8F%96%E5%8D%95%E9%93%BE%E8%A1%A8%E5%90%8E%E7%BB%A7%E5%85%83%E7%B4%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取单链表后继元素</h3>
<pre><code class="language-c">// 获取指定元素的后继元素
bool NextElem(LinkList L,int cur_e,int &amp;next_e){
    LinkList p = L-&gt;next;      // p指向头结点的下一个节点
    while(p &amp;&amp; p-&gt;next){       // 当p和p的下一个节点不为空时
        if(p-&gt;data == cur_e){  // 如果p的值等于要查找的元素
            next_e = p-&gt;next-&gt;data;  // 则p的下一个节点的值为目标元素的后继元素
            return TRUE;       // 返回true
        }
        p = p-&gt;next;           // p指向下一个节点，继续遍历
    }
    return ERROR;              // 没有找到目标元素，返回ERROR
}
</code></pre>
<h3><a id="%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在单链表中任意位置插入元素</h3>
<pre><code class="language-c">bool InsertList(LinkList L,int i,int e){
    int j = 0; // 用于记录链表中已经遍历过的结点个数
    LinkList q,p = L; // q用于指向要插入的新结点，p用于指向当前结点的前一个结点
    while (p &amp;&amp; j&lt;i-1) { // 循环找到第i-1个结点
        j++;
        p = p-&gt;next;
    }
    if(!p||j&gt;i-1) // 判断是否找到了第i-1个结点，如果没有或者已经超出链表长度则返回错误
        return ERROR;
    q = (LinkList)malloc(sizeof(LNode)); // 创建新结点
    q-&gt;data = e; // 给新结点赋值
    q-&gt;next = p-&gt;next; // 将新结点的next指针指向第i个结点
    p-&gt;next = q; // 将第i-1个结点的next指针指向新结点
    return TRUE; // 返回成功插入的标志
}
</code></pre>
<h3><a id="%E5%88%A0%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>删除单链表中指定元素</h3>
<pre><code class="language-c">bool DeleteLink(LinkList L,int i,int &amp;e){
    LinkList q,  p= L; // q用于指向要删除的结点，p用于指向当前结点的前一个结点
    int j = 0; // 用于记录链表中已经遍历过的结点个数
    while(p-&gt;next &amp;&amp; j&lt;i-1){ // 循环找到第i-1个结点
        j++;
        p = p-&gt;next;
    }
    if(!p-&gt;next || j&gt;i-1) // 判断是否找到了第i-1个结点，如果没有或者已经超出链表长度则返回错误
        return ERROR;
    q = p-&gt;next; // 找到要删除的结点
    p-&gt;next = q-&gt;next; // 将第i-1个结点的next指针指向第i+1个结点
    e = q-&gt;data; // 用于返回删除的结点的数据
    free(q); // 释放要删除的结点的空间
    return TRUE; // 返回成功删除的标志
}
</code></pre>
<h3><a id="%E6%89%93%E5%8D%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%84print%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>打印单链表元素的print函数</h3>
<pre><code class="language-c">void PrintList(LinkList L) {
    if (L == NULL || L-&gt;next == NULL) {
        printf(&quot;链表为空！&quot;);
        return;
    }
    LinkList p = L-&gt;next;
    while (p != NULL) {
        printf(&quot;%d &quot;, p-&gt;data);
        p = p-&gt;next;
    }
    printf(&quot;\n&quot;);
}
</code></pre>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  

	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>